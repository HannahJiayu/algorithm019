[TOC]
#6. 动态规划（Dynamic Programming,动态递推）学习笔记
##6.1感触：
1. 人肉递归低效，很累；
2. 如果一个问题很复杂，可以试图寻找最近最简方法，将其拆解成可重复解决的问题；
3. 培养数学归纳法的思维方式，抵制人肉递归的诱惑；先把n = 1, n = 2基本条件下的问题想明白，然后再去递推到n,n+1的情况；
4. 算法的**本质**就是寻找重复性；
5. 如果一定要人肉递归，可以画出问题的递归树。

##6.2动态规划
1. 分治+最优子结构（比如，最小，最大...要证明如果每一步只存最优的子结构的值，最终能够推导出一个全局的最优的值）；
2. 动态规划（动态递推）和递归、分治没有本质上的区别（关键看有没有最优的子结构）；
3. 共性：找到重复子问题；
4. 差异：动态规划存在最优子结构，中途可以淘汰次优解（也必须淘汰次优解）；
5. 如果不淘汰次优解而进行傻递归、傻分治会导致指数级的时间复杂度，利用动态规划可以将时间复杂度降至为多项式级别（O(n),O(n^2))。

##6.3习题
### 6.31 Fibonacci数列（一维数组递推）
    在傻递归的基础上，有以下两种改进方法：
    1. 在递归过程中加入**记忆化搜索**数组；（注意优化代码的逻辑，保持代码的简洁（right clean code））
    2. 递推：将递归的顺序反向，写成一个循环

    * 复杂一些的动态规划是在傻递推的基础上，有了两个变化：
        - 从一维变到多维
    * 递推过程中包含最优子结构，可以淘汰一些次优解

### 6.32 路径计数
    1. 首先，自顶向下找到子问题；
    2. 然后，自底向上递推。
    3. 优化：不需要将所有的状态全部存下来，因此可以用一维数组来代替二维数组；

### 6.33 最长公共子序列
    1.两个字符串的问题通常会被构造成一个二维数组的形式
    2.定义base case很重要，在此问题中，在矩阵中加入‘’会是初始化变简单，否则要多加语句进行初始化；
### 6.24 爬楼梯  
    扩展：步幅变为1，2，3；临近两步不可以走一样的步数

### 6.25 三角形最小路径和  
    了解算法思想后，如何写代码还是一个很技术的活，比如如何初始化数组会比较方便
    + 练习记忆化搜索

```python
method1:
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        dp = triangle[-1][:]
        print(dp)
        for i in range(len(triangle) -2, -1, -1):
            for j in range(len(triangle[i])):
                dp[j] = triangle[i][j] + min(dp[j], dp[j+1])
        return dp[0]
method2:
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        dp = triangle[:]
        for i in range(len(triangle) -2, -1, -1):
            for j in range(len(triangle[i])):
                dp[i][j] += min(dp[i+1][j], dp[i+1][j+1])
        return dp[0][0]
```
### 6.26 零钱兑换
    1)可以利用BFS递归状态树来求解
    2)转换子问题时，首先从[1,2,5]单角度考虑子问题，发现并没有思路，此时应立即转换思路，观察11这个角度，考虑定义子问题
    ![递归状态树](/Users/jiayuhan/Documents/algorithm019/Week_06/coin_change.png "图片title")

### 6.27  打家劫舍
    python版本还没有想明白
### 6.28 解码方法：
```python
if s[i-1] == '1' or s[i-1] == '2' and s[i] >= '1' and s[i] <= '6':
    ?为什么加上括号不行呢？Reply:因为加错地方了。。。如果s[i-1] == '1'对s[i]是没有要求的
```
###6.29 任务调度器
    ？？和动态规划有什么关系？？
    collections.Counter

###6.30 最长有效括号
    Tip：动态规划也需要分情况讨论

+ **小结**：
    1. 打破自己的思维惯性，形成机器思维  
    2. 理解复杂逻辑的关键
    3. 五步DP
        1. 设计子问题
        2. 猜答案
        3. 合并相关子问题的解
        4. 递归、记忆化或dp
        5. 解决原问题


###动态规划关键点
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], ...)
2. ！储存中间状态：opt[i]
3. 递推公式--状态转移方程：有筛选过程
