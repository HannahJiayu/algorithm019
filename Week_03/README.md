[TOC]
# å­¦ä¹ ç¬”è®°
## é€’å½’æ€æƒ³ å½’å»æ¥å…®
>1.ç»“ç‚¹çš„å®šä¹‰ï¼ŒåŒ…æ‹¬æ•°æ®ç»“æ„åŠç®—æ³•ç‰¹æ€§çš„å®šä¹‰ï¼›
>
2.é‡å¤æ€§ï¼ˆè‡ªç›¸ä¼¼æ€§ï¼‰;
>
3.é€’å½’å’Œå¾ªç¯ä¸¤è€…çš„æ±‡ç¼–è¯­è¨€ç±»ä¼¼;


+ æ ‘é€’å½’

+ æ³›å‹é€’å½’
+ é€’å½’ä»£ç æ¨¡ç‰ˆ

```python
def recursion(level, param1, param2, ...): 
    #1 recursion terminator 
    if level > MAX_LEVEL: 
       process_result 
       return 

    #2 process logic in current level 
    process(level, data...) 

    #3 drill down 
    self.recursion(level + 1, p1, ...) 

    #4 reverse the current level status if needed
```
### æ€ç»´è¦ç‚¹
>1. ä¸è¦äººè‚‰é€’å½’

>2. **æ‰¾æœ€è¿‘é‡å¤å­é—®é¢˜**

>3. æ•°å­¦å½’çº³æ³•çš„æ€ç»´
### ä¹ é¢˜
#### 1. ç”Ÿæˆæ‹¬å·
è¦ç‚¹ï¼š1.åˆ©ç”¨å‚æ•°ä¼ é€’å·¦ã€å³æ‹¬å·çš„æ•°é‡ï¼›2.if-elseçš„drill downï¼›
#### 2. ç¿»è½¬äºŒå‰æ ‘
è¦ç‚¹ï¼šä¾æ¬¡ç¿»è½¬å·¦ã€å³ç»“ç‚¹ï¼Œç¿»è½¬å®Œåœ¨è¿”å›æ ¹
#### 3. éªŒè¯äºŒå‰æœç´¢æ ‘
è¦ç‚¹ï¼šèŠ‚ç‚¹çš„å·¦å­æ ‘å°äºèŠ‚ç‚¹ï¼Œå³å­æ ‘å°äºèŠ‚ç‚¹ï¼Œæ‰€æœ‰çš„å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ï¼›
>é€’å½’æ–¹æ³•ï¼šè‡ªé¡¶å‘ä¸‹ï¼Œçˆ¶èŠ‚ç‚¹çš„å€¼ä¾æ¬¡æ˜¯å·¦ã€å³ç»“ç‚¹çš„ä¸Šã€ä¸‹ç•Œ,åˆ©ç”¨çˆ¶èŠ‚ç‚¹æ¥çº¦æŸå­èŠ‚ç‚¹
#### 4. äºŒå‰æ ‘çš„æœ€å°æ·±åº¦
è¦ç‚¹ï¼šæ‰¾åˆ°æœ€å°é‡å¤ï¼Œå°†3ä¸ªèŠ‚ç‚¹æˆ–ä¸¤ä¸ªèŠ‚ç‚¹çš„æƒ…å†µæƒ³æ¸…æ¥šï¼Œç„¶åå†™å‡ºé€’å½’
#### 5.äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ–
è¦ç‚¹ï¼šè¦å°†ä¸€å±‚çš„é€»è¾‘éƒ½å¤„ç†å®Œå†åšå…¶ä»–çš„äº‹æƒ…ï¼›
æ³¨æ„ï¼šå­—ç¬¦ä¸²å’Œintçš„è½¬åŒ–å¯èƒ½ä¼šå¯¼è‡´åˆ¤ç­‰å‡ºç°é—®é¢˜ï¼›åˆ©ç”¨ï¼Œ.join(res)æ¥é¿å…ï¼›
#### 6.
## åˆ†æ²»ã€å›æº¯çš„å®ç°å’Œç‰¹æ€§
###åˆ†æ²»
divide -> conquer -> merge
å…³é”®ç‚¹ï¼šå¦‚ä½•æ‹†åˆ†å­é—®é¢˜ï¼ˆä¾é ç»éªŒï¼‰ï¼›å¦‚ä½•åˆå¹¶å­é—®é¢˜çš„ç»“æœ
1.terminator 2.processï¼ˆsplit your big problemï¼‰3.subproblemï¼Œ merger4.reverse status

###å›æº¯
è¯•é”™ï¼šä¸æ–­åœ¨æ¯ä¸€å±‚ä¸Šè¿›è¡Œå°è¯•ï¼›
å½’å»æ¥å…®çš„æ„Ÿè§‰

```python
def divide_conquer(problem, param1, param2, ...): 
  # recursion terminator 
  if problem is None: 
    print_result 
    return 

  # prepare data 
  data = prepare_data(problem) 
  subproblems = split_problem(problem, data) 

  # conquer subproblems 
  subresult1 = self.divide_conquer(subproblems[0], p1, ...) 
  subresult2 = self.divide_conquer(subproblems[1], p1, ...) 
  subresult3 = self.divide_conquer(subproblems[2], p1, ...) 
  â€¦

  # process and generate the final result 
  result = process_result(subresult1, subresult2, subresult3, â€¦)
    
  # revert the current level states
```
![é€’å½’çŠ¶æ€æ ‘](/Users/jiayuhan/Documents/algorithm019/Week_03/recursion_tree.png "å›¾ç‰‡title")
####1.Powï¼ˆx,n)
è¦ç‚¹ï¼šæ³¨æ„n<0æ—¶çš„å¤„ç†ï¼›åˆ†æ²»+é€’å½’çŠ¶æ€æ ‘  
æ€è€ƒğŸ¤”ï¼šå¦‚ä½•åˆ©ç”¨åˆ†æ²»+è¿­ä»£
####2.äºŒå‰æ ‘çš„æœ€è¿‘ç¥–å…ˆ
è¦ç‚¹ï¼šè¿™æ˜¯ä¸€é“æ ‘ç›¸å…³çš„é—®é¢˜ï¼Œä¸æ ‘ç›¸å…³å¯ä»¥åˆ©ç”¨é€’å½’è§£å†³ï¼Œå› æ­¤è¦æ‰¾åˆ°å¦‚ä½•å®šä¹‰å­é—®é¢˜  
å…¬å…±ç¥–å…ˆçš„å®šä¹‰ï¼šå­æ ‘åŒ…å«pï¼Œqç»“ç‚¹  
é¦–å…ˆå®šä¹‰å‡ºå£æ¡ä»¶ï¼Œç„¶åä»ä¸Šè‡³ä¸‹åˆ¤æ–­å½“å‰ç»“ç‚¹æ˜¯å¦å¯èƒ½æ˜¯å…¬å…±ç¥–å…ˆï¼›  
åˆ¤æ–­é€»è¾‘ï¼šåˆ†åˆ«é€’å½’å·¦å³å­æ ‘ï¼Œå¯»æ‰¾pï¼Œqç»“ç‚¹ï¼Œæ ¹æ®å¯»æ‰¾ç»“æœè®¾è®¡åˆ¤æ–­é€»è¾‘
>å¦‚æœå·¦ã€å³å­æ ‘è¿”å›çš„ç»“æœå‡ä¸ºéç©ºï¼Œé‚£ä¹ˆrootä¸ºcommon ancestor
>å¦‚æœå·¦å­æ ‘ä¸ºç©ºï¼Œé‚£ä¹ˆè®¿é—®å³å­æ ‘æ—¶ï¼Œç¬¬ä¸€ä¸ªpï¼Œqä¸­çš„ç»“ç‚¹ä¾¿æ˜¯anncestor

ps:è°ƒç”¨é€’å½’æ—¶ï¼Œå¯ä»¥å°†çˆ¶èŠ‚ç‚¹ä½œä¸ºå‚æ•°ä¼ å…¥








